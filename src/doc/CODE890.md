# Code890: Final Project, cs591

## What to Hand in

For each of the following tasks, create a sub-directory called
CODE8, CODE9, CODE10 that includes:

+ All related python code
+ A README.md file containing your report.
+ Sub-directories CODEx/img for images; CODEx/data for data.

Using some URL shortener (e.g. goo.gl), shorten the URL to `hw/code/x`
and paste into [the submission page](https://goo.gl/lZEmEm).


## What to do

For each of the following,
write a report (1500 words+) applying the stats (Scott-Knott, a12) on performance data
collected from different optimizers on five hard models (see [Table1](http://e-collection.library.ethz.ch/eserv/eth:24696/eth-24696-01.pdf)) using

Your report should

+ Explain all algorithms (so I know that you know what is going on in them)
+ The whole report should be a _story_ that take the reader from some initial shared place to some final new and exciting place.

## Code8


For DE and MWS and SA, code up the Type1,Type2, Type3 comparison operators and use them to:

+ Find the final era computed by DE, MWS, SA (with early termination)
+ Computer the _loss_ numbers between era0 the final era
     + Important implementation note: repeat the above with 20 different baseline populations. For each baseline, run DE,MWS,SA.

Apply the above for DTLZ7 with 2 objectives 10 decisions.



### A standard genetic algorithm

+ Mutation: at probability 5%
+ Crossover: one point (i.e. pick a random decision, take all dad's decisions up to that point, take alll mum's decisions after that point)
+ Size of population: 100
+ Number of generations: 1000 (but have early termination considered every 100 generations)

### 
Basic Differential Evolution

Read the [lecture](DE.md) on Differential Evolution

To the generic experimentation loop of Code6,
add

+ DE
+ Yet another model: Golinski (from the usual place).

For energy, use the fromHell calculation to generate an aggregate

+ Generate the frontier
+ For each candidate, evaluate the objectives
+ Incrementally track of the _min,max_ seen for each objective
+ Run back over the frontier, computing the aggregate score
  (note that hell = 1 and so _g<sub>1</sub>_ = _fromHell_ for one objective
  _f<sub>1</sub>_ is the
  normalized distance to 1. Then, the aggregate energy for _n_ objectives    
  _e = 1 - sqrt(sum( g<sub>i</sub><sup>2</sup> )) / sqrt(n)_


(Aside: We use "_1 - "_ so this becomes a value we want to minimize. So we say
candiadte1 is better than candidate2 if it generates lower energy.)

Now, after frontier0, if we incrementally track min
max objective scores then all future candidates can
be stamped with their _"e"_ just as soon as they are
created.


Try and make a report that looks like the output from SA.

## DE(s) = DE + elite sampling

Try some elite sampling, keeping the _s_ best items in frontier. At the _start_ of each
generation of DE, sort the frontier by the aggregate and find the min/max aggregate
score (these will be found at the start and end of the list). Let _small_ be

_min + (max-min)*s/100_

(e.g. at _s=33_ you are keeping just the best 33% of of the frontier as scored
by the aggregate score).

For all the models you are currently running, collect the
the median values of energy in the the last era generated by DE(s) for s in _(12,25,33,50,100)_ (note that _s=100_ makes DE(s) the same as standard DE). Offer a conclusion: is DE(s) useful?

(Aside: comparing just the medians is kind of brain dead but until we
have the stats machinery of CODE8, its the best we can do for now.)

## Tips

### As before Not everything is "ok".


Note that this model has constraints-- so after you
_mutate_ a solution, you must check if it is _ok_
(I.e. does not violate the constraints-- otherwise,
mutate again until ok).


