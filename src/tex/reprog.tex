\subsection{Research Programming}\label{research-programming}

Silliness aside, this book is about how to be a \emph{research
programmer}. Research programmer's understand the world by:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Codify out current understanding of ``it'' into a model.
\item
  Reasoning about the model.
\end{itemize}

We take this term ``research programmer'' from Ph.D.~Steve Guao's 2012
dissertation.

\subsubsection{Challenges with Research
Programming}\label{challenges-with-research-programming}

Research programming sounds simple, right? Well, there's a catch
(actually, there are several catches).

Firstly, models have to be written and it can be quite a task to create
and validate a model of some complex phenomenon.

see also list in sbse14

Secondly, many models related to \emph{wicked problems};
i.e.\textasciitilde{}problems for which there is no clear best solution.
Tittel XXXWorse still, some models relate to \_wicked there is final
matter of the \emph{goals} that humans want to achieve with those
models. When those goals are contradictory (which happens, all too
often), then our model-based tools must negotiate complex trade offs
between different possibilities.

Thirdly, if wicked problems were not eough, there is also the issue of
uncertainty. Many real world models contain large areas of uncertainty,
especially if that model relates to something that humans have only been
studying for a few decades.

Fourthly, even if you are still not worried about the effectiveness of
reserach problem, consider the complexity of real-world phenomonem. Many
of these models are so complex that we cannot predict what happens when
the parts of that model interact.

Sounds simple, right? Well, there's a catch. Many models related to
\emph{wicked problems}; i.e.~problems for which there is no clear best
solution. Tittel XXXWorse still, some models relate to \_wicked there is
final matter of the \emph{goals} that humans want to achieve with those
models. When those goals are contradictory (which happens, all too
often), then our model-based tools must negotiate complex trade offs
between different possibilities.

If wicked problems were not eough, there is also the issue of
uncertainty. Many real world models contain large areas of uncertainty,
especially if that model relates to something that humans have only been
studying for a few decades.

And if you are still not worried about the effectiveness of reserach
problem, consider the complexity of real-world phenomonem. Many of these
models are so complex that we cannot predict what happens when the parts
of that model interact.

\subsubsection{Parts}\label{parts}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Domain specifc langauges (representation)
\item
  execution (nuktu-objective ootiization)
\item
  evaluation (statistical methods for experimental sciencetists in SE)
\item
  Philophsopy (about what it means to know, and to doubt)
\end{itemize}

\subsubsection{Implications for Software
Engineering}\label{implications-for-software-engineering}

Note that research programming changes the nature and focus and role of
21st century software engineering:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Traditionally, software engineering is about services that meet
  requirements.
\item
  But with research programming, software engineering is less about
  service than about search. Research programming's goal is the
  discovery of interesting features in existing models (or perhaps even
  the evolution of entirely new kinds of models).
\end{itemize}

For example, old-fashioned software engineerings might explore small
things like strings or ``hello world''. But with research programmers
explore \textbf{BIG} things like String Theory or ``hello world model of
climate change and economic impacts''.
